package kau.midterm

/*

    코틀린이 Int와 같은 기본 자료형도 객체 취급 이유
    - 일관성 : 모든 것을 객체로 취급함으로써 언어 일관성 유지
    - 확장 함수 : 기본 자료형에도 확장 함수 사용하도록
    - Null 안전성 : 기본 자료형도 nullable

    Kotlin이 val, var 구분하는 이유
    - 가변성 제어 : 불변과 가변
    - 안전성 : val을 사용하면 값 변경 X
    - 가독성 : 변수 의도 표현
    - 성능 : 최적화

    함수 내 함수 장점
    - 캡슐화 : 특정 함수에서만 사용되는 로직을 내부에 숨김
    - 중복 제거

    패키지 장점
    - 코드 구조화 : 관련 클래스 및 인터페이스 그룹화하여 코드 체계적 관리
    - 이름 충돌 방지
    - 접근 제어

    코틀린이 범위 등 변수로써 제공하는 이유
    - 명확성
    - 가독성
    - 확장 함수

    try-catch-finally 필요한 이유
    - 예외 처리 : 예외 발생할 수 있는 코드 예방
    - 로깅 : 로그 남겨서 사용자에게 알림 제공

    catch 와 finally 차이
    - 예외 발생시 catch
    - 예외와 상관없는 finally

    객체와 구조체의 차이점
    - 데이터와 함수
    - 상속
    - 접근 제어(가시성)

    함수가 자료구조 안으로 들어올 때의 장점
    - 캡슐화
    - 데이터 보호
    - 추상화
    - 코드 재사용성
    - 유지보수성

    필드와 프로퍼티 차이
    - 필드
        - 클래스 내부 변수
        - 데이터 직접 저장
        - 일반적으로 private라서 외부 접근 X
    - 프로퍼티
        - 필드 값 읽는 getter, setter 포함 개념
        - 데이터 접근
        - 외부는 필드처럼 보이나, 내부는 메서드로 구현

    뒷받친 field
    - 실제 데이터 저장
    - 메모리 사용
    - 일반적인 변수처럼

    lateinit 과 by lazy 차이
    - lateinit
        - var 가변 변수만 사용가능
        - 초기화 시점을 개발자가 제어
        - null이 될 수 없는 타입
    - by lazy
        - val 불변 변수만 사용 가능
        - 첫 접근 시점에 자동으로 초기화

    lateinit & by lazy 필요 이유
    - 객체 생성 시점과 초기화 시점 분리

    객체지향 프로그래밍 특징
    - 캡슐화 : 데이터 은닉, 객체 외부로부터 보호
    - 상속 : 코드 재사용과 확장
    - 다형성 : 객체는 상황에 따라 다른 동작 가능
    - 데이터와 함수 함께 정의
    - 일상 요소와 클래스 및 객체  개념 유사

    - 구조의 복잡성
    - 더 많은 메모리
    - 실행 속도 저하


 */